# 웹 애플리케이션과 영속성 관리
- JPA에 대한 내부 동작 방식을 이해한다.

### 1. 트랜잭션 범위의 영속성 컨텍스트
- 순수한 J2SE환경에서는 JPA사용 시 개발자가 직접 엔티티 매니저를 생성, 트랙잰션 관리를 해야하지만 J2EE 컨테이너 환경에서는 컨테이너가 제공하는 전략에 따라야 한다.

#### 1) 스프링 컨테이너의 기본 전략(영속성 컨텍스트 전략)
- 스프링 컨테이너는 **트랜잭션 범위의 영속성 컨텍스트** 전략을 기본으로 사용한다.
- 즉 트랜잭션 범위와 영속성 컨텍스트 생존 범위가 같다는 뜻이다.
- 서비스단에서 트랜잭션 시작 시 AOP에 의해 트랜잭션이 진행되고 커밋 될 때 플러시가 일어나 영속성 컨텍스트 내용이 반영된다.

**트랜잭션이 다르면 다른 영속성 컨텍스트를 사용한다.**
- 같은 엔티티 매니저하에 있더라도 트랜잭션이 다르면 다른 영속성 컨텍스트를 사용한다.
- 스프링 컨테이너는 스레드마다 다른 트랜잭션을 할당하므로 멀티 스레드환경에서 안전하게 사용 가능하다.
- 스프링, J2EE 컨테이너의 가장 큰 장점이 멀티 스레드 상황을 관리해주기 때문에 개발자는 싱글 스레드를 사용하는것과 같이 단순하게 개발할 수 있게되어 비즈니스 로직에 집중할 수 있다.

### 2. 준영속 상태와 지연 로딩
- OSIV를 사용하지 않고 기본 전략을 사용하면 프레젠테이션 계층에서는 엔티티가 준영속 상태이므로 변경 감지, 지연 로딩이 불가능하다.
- OSIV를 사용하지 않고 이 문제를 해겨하기 위해서는 크게 글로벌 페치 전략(즉시로딩), 페치 조인, 강제 초기화를 사용하면 된다.
- 글로벌 페치 전략, 페치 조인은 넘어간다.

#### 1) 강제 초기화 및 확인법
```java
// 강제 초기화 방법
Hibernate.initialie(order.getMember());

// 초기화 확인(테스트 코드 작성 시 유용할 듯)
per = em.getEntityManagerFactory().getPersistenceUnitUitl();
isLoaded = per.isLoaded(orget.getMember());
```

#### 2) FACADE 계층 추가
- 프레젠테이션과 서비스 계층 사이에 FACADE 계층을 하나 둔다.
- 해당 계층에서 뷰를 위한 프록시를 초기화하는 담당을 한다.
- 이를 통해 서비스, 프레젠테이션 계층 사이에 논리적인 의존성을 분리할 수 있다.
- 해당 계층에는 트랜잭션이 필요하므로 트랜잭션을 걸어주어야 한다.

```java
// 여기서 초기화를 담당한다.
class OrderFacade{
  private final OderService ov;

  public Order findO(id){
    Order o = ov.findOrder(id);
    o.getMember().getName();
    return order;
  }
}
```


> 이러한 방법들을 사용하면 트랜잭션의 범위가 작으므로 많은 커넥션이 요구될 때 효율적이 겠지만 그렇지 않은 경우에는 많은 시간이 소모된다. 이럴 때 Open Session In View를 걸어두면 프레젠테이션 계층까지 영속성 컨텍스트를 유지 시킬 수 있다.

### 3. OSIV(Open Session In View)
- 말 그대로 세션을 뷰까지 열어준다는 것이다.

#### 1) 과거 OSIV: 요청 당 트랜잭션
- 스프링에서는 간단하게 필터나 인터셉터에서 트랜잭션을 걸면된다.
- 이것을 보통 트랜잭션 방식의 OSIV이라 한다.
- 가장 큰 문제점은 프레젠테이션 계층에서 변경 감지로 인한 데이터를 변경할 수 있다는 점이다.
- 서비스 계층에서는 비즈니스 로직을 담당하므로 괜찮지만 뷰단에서 데이터를 변경하는건 유지보수에 좋지 않다.
- 프레젠테이션 계층에서 엔티티를 수정하지 못하도록 하여 이 문제를 해결할 수 있다.

#### 문제 해결법
- 해결법은 크게 엔티티를 읽기 전용 인터페이스로 제공, 엔티티 래핑, DTO로 반환이 있다.

**엔티티를 읽기 전용 인터페이스로 제공**
```java
interface MemberView{
  public String getName();
}

@Entity
class Member implements MemberView{}

class MemberService{
  public MemberView getMember(id){
    return memberRepo.findByid(id);
  }
}
```
- 서비스 단에서는 MemberView를 반환하도록 한다.

<br>

**엔티티 래핑**
```java
class memberWapper {
  private Member member;
  public String getName(){
    member.getName();
  }
}
```
- 엔티티를 한 번 깜싼다.

<br>

**DTO 반환**

> 이러한 방법은 생산성이 떨어질 수 있다. 그러하여 스프링에서는 기본적으로 OSIV를 제공해주는 방법이 있다.

#### 2) 스프링 OSIV: 비즈니스 계층 트랜잭션
- 스프링 프레임워크의 spring-orm.jar에서는 다양한 OSIV 클래스를 제공한다.
- OSIV를 서블릿 필터, 스프링 인터셉터에 적용할 지 직접 지정할 수 있다.
- OpenSessionInViewFilter, Interceptor(하이버 네이트)
- OpenEntityManagerInViewFilter, Interceptor(JPA)
- JPA를 사용하면서 OSIV를 적용하려면 JPA꺼를 사용하면 된다.

#### 스프링 OSIV의 장점
- 이전의 OSIV는 프레젠테이션 계층에서 데이터를 변경할 수 있지만 스프링의 OSIV는 이러한 문제를 어느정도 해결해 준다.
- 동작원리는 요청이 들어올 때 영속성 컨텍스트 생성을 하고 서비스단에 갈 때 트래잭션을 시작한 후 서비스 단에 나갈 떄 트랜잭션을 완료하고, 영속성 컨텍스트는 살려준다.
- 자세히 한번 알아보자

**동작 원리**
1. 요청이 들어오면 필터 혹은 인터셉터에서 영속성 컨텍스트 생성, 트랜잭션은 시작 안함
2. 서비스 계층에서 @Transactional로 트랜잭션 시작 시 생성해둔 영속성 컨텍스트를 찾아와 트랜잭션을 시작
3. 서비스 계층 끝나면 트랜잭션 커밋, 영컨 플러시한다. 이때 트랜잭션은 끝내지만 영속성 컨텍스트는 종료하지 않는다.
4. 컨트롤러, 뷰 까지 영컨 유지하므로 조회한 엔티티 영속 상태는 유지된다.
5. 필터, 인터셉터에게 요청이 돌아올 때 영컨을 종료 한다. 이 때는 플러시를 호출하지 않으므로 디비 반영안된다.

> 트랜잭션 없이 영컨을 플러시하게 되면 TransactionRequiredException 예외가 발생한다.

- 그러므로 영컨은 트랜잭션 범위 안에서 엔티리를 조회하고 수정할 수 있지만 밖에서는 조회만 가능하다.
- 이를 **트랙잰션 없이 읽기(Nontransactional reads)** 라고 한다.
- 만약 플러시를 강제로 호출하더라도 트랜잭션 범위 밖이므로 데이터를 수정할 수 없다는 예외를 만난다.

**스프링 OSIV 주의사항**
```java
class MemberController{
  public String viewmem(id){
    Member memeber = memService.getMem(id);
    member.setName("123");

    memService.biz();
    return "view";
  }
}
```
- 이렇게 멤버를 받아오고 데이터를 변경 한 후 비즈니스 로직을 실행하는 서비스를 호출했다.
- 이럴 경우 영속성 컨텍스트는 계속 지속되므로 변경감지가 발생할 수 있다.
- 해결법은 비즈니스 로직을 먼저 호출하면 된다.
- 보통 비즈니스 로직을 먼저 호출하는게 일반적인 흐름이므로 약간의 주의만 한다면 큰 문제는 없을 것이다.

#### 3) OSIV 정리
**스프링 OSIV 특징**
- 요청이 들어올 때 영속성 컨텍스트를 해당 요청이 인터셉터나, 필터로 돌아 올 때 까지 유지한다.
- 엔티티 수정은 트랜잭션이 있는 계층에서만 동작하고 그 외에는 플러시를 날리지 않고, 트랜잭션이 없으므로 문제가 발생하지 않는다.

**스프링 OSIV 단점**
- OSIV사용 시 같은 영속성 컨텍스트가 트랜잭션을 공유하는 문제를 주의하자. 이는 15.1에 나와 있을 것이다.
- 엔티티 수정 문제에 대해 주의하자.
- 지연 로딩에 대한 성능 이슈를 잘 확인하자.
